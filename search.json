[{"title":"C++笔记1","url":"/2022/01/28/C++%E7%AC%94%E8%AE%B01/","content":"类\n成员函数属于类而数据成员属于对象\ntypedef struct Student&#123;\tint x;\tchar *name;&#125;N;//用N代替Studenttypedef int *N;N p;//p为int*类型typedef int array[10];array a;//相当于int a[10];//把变量名替换成新类名\n构造函数（默认与重载）\nClassA();//无参构造函数，默认构造函数ClassA(int a,int b,int c=10);//重载ClassA(10,10,10);//全部为默认参数，属于默认构造函数，//在声明时指定默认值，而不需要在定义时再指出来ClassA x;        //只能有一个默认构造函数，而且最好不要把有默认参数的构造函数和重载放在一起使用\n\nConst\n常指针，指向地址不变  int *const p; \n\n指针常量，不能修改指向的值  const int *p ,int const *p;\n\nconst默认作用于其左边，否则右边。  \n\n\n类模板template&lt;class T&gt;class Student&#123;&#125;; //模板类定义Student&lt;int&gt;a; //用模板类定义对象实体template&lt;class T&gt;void Student&lt;int&gt;::print()&#123;...&#125;;//在模板类外定义成员函数，每一条头部都要加template\t\n\n\n\n构造函数1.默认构造函数\n无参数\n\n所有参数均给出默认值\n\n\n二者有一定区别，第二种可以指定参数传入，会将默认值替换掉。只有定义了默认构造函数才能初始化对象。\nStudent(int a=5, int b=5)//func1\t&#123;\t\tx = a;\t\ty = b;\t&#125;Student()//func2&#123;    x=5;    y=5;&#125;//二者都是默认构造函数，不能同时出现，二者有区别。//以下两种方式都可以调用默认构造函数,无论是func1还是func2Student st；Student st1=Student();\n\n//派生类构造函数调用直接基类构造函数是可以选择Circle::Circle(int a,int b,int c):Point(a,b)&#123;\t\t\t\t\t\t\t\t\t\t\t\t//参数化列表可用于调用基类构造，初始化r也可，初始化类子对象\tr = c;&#125;\n\n2.赋值构造函数Student st2;st2=st;  //相当于赋值给一个已经被构造函数初始化过的对象，而复制构造函数是将未初始化的进行初始化。\n\n3.复制构造函数\n用已存在对象初始化一个新对象时\n\nStudent st2=st1;\n\n\n函数参数为对象时\n\nvoid func1(Student &amp;st)&#123;&#125;   //将实参复制一个形参传入\n\n\n返回值为对象时\n\nStudent func2()&#123;return st;&#125;  //返回时复制一个临时对象返回，其他函数内部的东西在函数结束时释放了，因此不能返回局部变量的引用值\n\nextern变量extern int a; // 声明一个全局变量 aint a; // 定义一个全局变量 aextern int a =0 ; // 定义一个全局变量 a 并给初值。int a =0;    // 定义一个全局变量 a, 并给初值\n\n在定义变量的时候，这个extern居然可以被省略(定义时，默认均省略)；在声明变量的时候，这个extern必须添加在变量前，所以有时会让你搞不清楚到底是声明还是定义。或者说，变量前有extern不一定就是声明，而变量前无extern就只能是定义。注：定义要为变量分配内存空间；而声明不需要为变量分配内存空间。\n声明不分配空间。而定义即使不赋值也会分配空间。声明可以多次，所以不能在头文件中定义，否则不能被多个文件include。\n在哪里使用变量就在哪里写extern，告诉编译器这个变量在其他地方定义了。\n在A文件中使用B文件中变量x的两种方法\n\n同一工程下，在A中extern int x，在B中定义x。\n\n在B.h中extern int x；B.cpp中定义；在A中#include”B.h”。相当于头文件帮你声明过了，你不用自己一个一个extern。\n\n\n函数由于声明和定义不一样，所以可以不必考虑extern。\n函数由于函数的定义和声明具有可见性的区别，所以可以省略extern。对于函数也一样，也是定义和声明，定义的时候用extern，说明这个函数是可以被外部引用的，声明的时候用extern说明这是一个声明。 但由于函数的定义和声明是有区别的，定义函数要有函数体，声明函数没有函数体(还有以分号结尾)，所以函数定义和声明时都可以将extern省略掉，反正其他文件也是知道这个函数是在其他地方定义的，所以不加extern也行。两者如此不同，所以省略了extern也不会有问题。\n\n\n手动extern 声明（extern可省略）\n在头文件中声明，引入头文件。不可在头文件中定义函数，使得头文件不可被多次引用。\n\n\nstatic和extern函数\nauto和extern变量\n123\n函数指针数组，\ninline函数定义必须放在.h文件中\n函数对象和函数指针\n输入控制#include&lt;iostream&gt;using namespace std;int a;while(1)&#123;\tcin&gt;&gt;a;\t//if(!cin)\tif(!cin.fail())&#123;\t\tcin.clear();\t\tcin.ignore(1024,&#x27;\\n&#x27;);\t\t//cin.sync();\t\tcontinue;\t&#125;&#125;\n\n数组作为参数==在C/C++中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针==\nCSDN，这里第一个例子中当data数组经过一个函数传进去之后，在里面就变成指针类型了。\n\n一维数组\n\nconst int n=10;int a[][n];//一维数组传参show(int *p);show(int a[]);//动态数组int *p;p=new int[10];\n\n\n\n\n二维数组，必须指定列数，否则系统无法分配行和列\n==二维数组做参数==\n\n\n//二维数组作为参数的两种写法void show(int a[][n]);  //n必须与实参相同！！void show(int (*p)[n]);//int (*p)[n]为指向n长度的地址块的指针 // 而int *p[n]为长度为n的指针数组//动态二维数组两种int(*p)[10];//1.已知列数时,动态分配多少行这样的p=new int[x][10？];//2.未知列数时，先开辟一个指针数组，每个指针开辟一行int **q=new int*  [row]; //申请row个指向一维数组的指针(row长度的指针数组，指针数组作为行数)for(int i=0;i&lt;row;i++)&#123;  q[i]=new int[col]; //row个数组，每个数组长度为col(col长度的块，块作为列)&#125;\n\nnew 函数返回值是开辟内存的地址，如果要开辟一个指针数组，那么只能将值返回给一个二级指针，因为返回值是指向指针的指针。固不能用int * q=new int *[10];\nmalloc 函数也是如此。\n\nfor(int i=0;i&lt;row;i++)&#123;  delete []p[i]; //删除所有的行数组空间，p[i]为指针变量，前面的[]代表指向的是一个数组空间，删除每一行&#125;delete []p; //删除p指向的列空间p=NULL;\n\n//mallocint **p=NULL,i=0;p=(int **)malloc(sizeof(int *)*SIZE);for(;i&lt;SIZE;i++)&#123;  *(p+i)=(int *)malloc(sizeof(int )*4);&#125;\n\n\n ==二维数组作为返回值该怎么写?==，int **和int[][10]的区别；见下程序已知列数的malloc返回值。\n 返回指针数组时用 **\n\n#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;    //动态二维数组    //new版本    int **p = NULL;    p = new int *[3];    for (int i = 0; i &lt; 3;i++)&#123;        p[i] = new int[3];        for (int j = 0; j &lt; 3;j++)&#123;            p[i][j] = i * 3 + (j + 1);        &#125;    &#125;    for (int i = 0; i &lt; 3;i++)&#123;        for (int j = 0; j &lt; 3;j++)&#123;            cout &lt;&lt; p[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;    //malloc版本    int **q = 0;    q = (int **)malloc(sizeof(int *) * 3);    for (int i = 0; i&lt; 3;i++)&#123;        q[i] = (int *)malloc(sizeof(int) * 3);        for (int j = 0; j &lt; 3;j++)&#123;            q[i][j] = i * 3 + j + 1;        &#125;    &#125;    for (int i = 0; i &lt; 3;i++)&#123;        for (int j = 0; j &lt; 3;j++)&#123;            cout &lt;&lt; q[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;    /***********************************************************************/    //动态二维数组（已知列长）    //new    int(*r)[3];//相当于指定了每一行行长度（即列数），再开辟n行    r = new int[2][3];    for (int i = 0; i &lt; 2;i++)&#123;        for (int j = 0; j &lt; 3;j++)&#123;            r[i][j] = i * 3 + j + 1;            cout &lt;&lt; r[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;    //malloc    int(*s)[2];    s = (int (*)[2])malloc(sizeof(int)*3*2); //注意这是指定了2列，s类型应当为int(*)[2],即2列的行指针类型，因此若写函数返回值时，就这样写。int *[2]    for (int i = 0; i &lt; 3;i++)&#123;        for (int j = 0; j &lt; 2;j++)&#123;            s[i][j] = i * 3 + j + 1;            cout &lt;&lt; s[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;\n\n\n\n\n\n\n\n\n while\n 形参不是const指针，不能传入const指针。而形参是const指针，既可以传入const也可以传入非const；\n\n指针*和引用&amp;做参数的区别指针任然是单向传值，把指针内容赋给一个临时指针变量。而引用是形参实参双向传递的，传递的就是实参本身。\nvoid show(int *p,int&amp; a)&#123;...&#125;int main()&#123;\tint x=1;\tint y=2;\tshow(&amp;x;y);  //注意，这里x是传指针(地址)，地址存放在新的临时变量p中；而y才是传引用。&#125;\n\n数组与指针表示int a[10];//地址 &amp;a[i]=a+i//取值 a[i]=*(a+i)// &amp;a是数组首地址，整块遇到的问题\n\n指针做参数遇到的问题在main函数中创建一个自定义类型 student *st 指针，将指针传入一个用于初始化的函数中，void show(student *) ，在里面使用new。然后利用 Print 函数输出时，会提示 st 未使用。\nstruct student&#123;\tint a;\tint b;&#125;;void show(student *st)&#123;\tst=new student[10];//...&#125;void Print(student *st)&#123;//...&#125;int main(&#123;\tstudent *st=0;\tshow(st);\tPrint(st);&#125;\n\n由于指针作为函数参数本质上仍然是传值，相当于在 show 函数内部一个新临时指针 st （而不是主函数的 st ）来执行 new，而 main 函数中的 st 指针仍然是0。解决办法就是将 show 函数返回值设置为 student* 类型，返回局部 st，在 main 函数中让st=st；或者是传递一个指针的引用。\nint main()&#123;\tstudent *st=0;\tst=student *show(st);\tPrint(st);&#125;\n\n原因类似于下面这种\nint main()&#123;    int *p = NULL;    int *s = p;    s = new int[10];    s[0] = 1;    //p = s;   //!!不加此语句，无法输出p[0]    cout &lt;&lt; p[0];&#125;//以及这种int main()&#123;    int *p = NULL;    int *s = p;    p = new int[10];    p[0] = 1;    cout &lt;&lt; s[0];//也会提示s是nullptr&#125;\n\n在不同函数中进行链表操作时也会遇到这样的问题，加一个头节点也可以解决这种问题。因为有了头节点，即使是传值也无所谓，即函数和主函数中的head都可以用来操作头节点中的变量，让head-&gt;next，指向下一个节点即可。\n\n如果函数内要改变的是指针指向的内容，传递指针值即可\n如果函数改变的是指针本身，需要传递指针的引用\n\nvoid ReadFile(student*head)&#123;\tstudent *q = head,*p=NULL;&#125;int main()&#123;    student *head;\thead = new student;\thead-&gt;next = NULL;\tReadFile(head);&#125;\n\n\n\n二维数组与指针int main()&#123;\tint a[3][3] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;\tint *p = a[1];\t//int *q = a + 1;\tcout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; a + 1 &lt;&lt; &quot; &quot; &lt;&lt; &amp;a[1] &lt;&lt; endl; //行地址\tcout &lt;&lt; a[0] &lt;&lt;&quot; &quot; &lt;&lt; *(a+1) &lt;&lt;&quot; &quot;&lt;&lt;a[1];//元素地址（某行第一个元素的地址）&#125;\n\n\n\n\n从上述代码的输出结果来看，好像两行是完全一致，事实上二组值意义完全不同。\n第一组表示的是行向量的  ==行地址==，而第二组代表的是对于行的==0列地址==。\n二维数组A[3][4]可以看作是三个元素a组成，每个元素a都是一个长度为 4 的数组。所以a和&amp;a[0] 代表的是第一个a元素的地址，*a 和 a[0] 则表示第一个a元素（长度为4的数组）的第一个元素的地址。\nint main()&#123;\tint a[3][3] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;\tint *p = a[1][1];\t//int *q = a + 1;\tcout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; a + 1 &lt;&lt; &quot; &quot; &lt;&lt; &amp;a[1] &lt;&lt; endl;\tcout &lt;&lt; a[0] &lt;&lt;&quot; &quot; &lt;&lt; *(a)+1 &lt;&lt;&quot; &quot;&lt;&lt;a[0]+1;   //对行地址解除引用得到元素a的值，即每个列数组的首元素地址&#125;\n\n\n\n\n\n\n\n\n\n二维数组在内存中连续存放，下图乍一看很秀的样子，其实都是利用了这一特性，p为列地址（第一行第一个元素），自增后指向第一行第二个，第一行结束后自增会指向第二行第一个元素，因为连续存放。\n\n这题很牛啊\n\n\n字符串其实就是一个个首地址，首先把四个字符串的首地址存放在一个指针数组里，即现在有4个指向这些字符串的指针，只要对这4个指针解引用* 即可得到四个字符串的地址，cout+首地址会输出整个字符串直到遇到&#39;\\0&#39;。\n新建一个指针数组 p，里面4个指针元素指向c+i（p[0]=*p+0=c+3） ，c+i 的意思是数组 c 四个元素（即前面的4个指针）的地址（因为*(c+i)==c[i]）。然后让指针 pp 指向 p 的首位，即 pp 中存放的是数组 p 第一个元素的位置。\n开始操作:  首先++ 优先级大于 * , pp 指向数组 p 中第二个元素。第一次解除引用，得到 c+2 ,(即数组 c 中元素的地址);第二次解除引用，即*(c+2)=c[2] ，得到第3个字符串__首地址__。输出即是==You==。\npp 和 p 是一样的，就像int *p,a[10];p=a;只是 pp 可以指向别处，而 p 只能指向数组第一个元素。pp[-2]=*(pp-2)，即 c+3 ，*(c+3) 得到最后一个字符串首地址，+3 是字符串第4个字符串地址，即空格，所以输出==空格+very== 。 \n\nNULL以下是C++一教材的解释:指针应在声明时或在赋值语句中初始化。指针可以初始化为0、NULL或—个地址。数值为0或NULL的指针不指任何内容。NULL是头文件&lt;iostream.h&gt;(和另外几个标准库头文件)中定义的符号化常量。将指针初始化为NULL等于将指针初始化为0，但C++中优先选择0。指定0时，它变为指针的相应类型。数值0是惟一可以不将整数转换为指针类型而直接赋给指针变量的整数值。\n指针指向 NULL 和空串&quot;&quot; 的区别，&quot;&quot; 里有一个 &#39;\\0&#39; ,虽然 NULL==&#39;\\0&#39;  ,但是一个是包含，一个是指向。\nchar a[] = &quot;&quot;;\tif(a[0]==&#x27;\\0&#x27;)\t\tcout &lt;&lt; 1;\tif(&#x27;\\0&#x27;==NULL)\t\tcout &lt;&lt; 2;\tif(NULL==0)          \t\tcout &lt;&lt; 3;//输出123\t//int*b=NULL;b==NULL;b!=&#x27;\\0&#x27;,c++标准规定不允许指针和值进行比较\n\n\n\n\n\n文件读取因为文件指针到最后一个字符时并不会触发eof,再读一次读不到数据才触发eof,这样c还保留着上一次的数据，又被输出一次，peek()方法是读取文件指针下一个位置的值，但并不移动文件指针，用在这里很合适\nifstream infile(&quot;&quot;,ios::in);while(!infile.eof())//我们利用while循环将文件读入char数组中while(infile.peek()!=EOF)//这两个的区别/*若不用peek，char数组会读入一个EOF，file.eof()并不会读文件，因此它必须在读取之后判断，所以当读到最后一个字符时，eof()不会读下一个，而是读当前的，因此当读到EOF之后，eof()才为真，此时才退出循环*///由于peek()和eof()一样只判断而不读取，而peek()是指向后一个，当读到最后一个字符，然后判断下一个是不是EOF，是就退出循环，就很科学了，\n\n所以正确的写法应当是先读&gt;&gt; 再判断；因为只有读了才能判断\n\n\n​    \n","categories":["c++"]},{"title":"Makefile","url":"/2022/01/28/Makefile/","content":"1. Makefile文件的作用及编写方法1.1 Makefile文件的作用​        \n1.2 Makefile文件的基本语法1.21 makefile作业\nmake命令 是否重新编译文件取决于文件的保存时间，因此即使是加了行注释也会被重新编译\n\n# 要求重新make后只重新编译修改过的文件objects = test1.o test2.o test3.otest:$(objects)\tgcc -Wall $(objects) -o test\techo &quot;编译成功&quot;\trm -f $(objects)#可要可不要test1.o:test1.c\tgcc -c test1.ctest2.o:test2.c\tgcc -c test2.ctest3.o:test3.c\tgcc -c test3.cclean:\trm -f test $(objects)\n\n\n\n\n指定test123.o文件的依赖项包含test.h，便可以达到要求 \n下面还用到了makefile的自动推导功能，将目标%.o 匹配默认规则，即利用gcc -c %.c 来自动生成 %.o目标。\n\n# 要求改动.h文件后重新make后所有文件重新编译objects =   test1.o test2.o test3.otest:  $&#123;objects&#125; test.h\tgcc -Wall $&#123;objects&#125; -o testtest1.o:test.h #注意这些.o目标都没有命令列表，自动推导出来test2.o:test.htest3.o:test.hclean:\trm -f test $&#123;objects&#125;\n\n\n自动化编译所有目录\n.PHONY作用：伪目标，避免命令和目录下实际文件名冲突造成无法执行\n@ 执行 shell 命令时不会回显\n\\用于连接每个 shell 语句，在一个进程中执行\n$$引用 shell 内部的变量，$引用 makefile 文件中的变量\n\n\n\n#自动执行所有目录下的所有makefileDIRS= $(shell ls -F | grep /$)   all:\t@for i in $(DIRS);do\\\t\tmake -C $$i;\\\t\tdone.PHONY= cleanclean:\t@for i in $(DIRS);do\\\t\techo &quot;delete&quot; $$i;\\\tdone\n\n\nmake 原理\ntarget:main.o test.o\tgcc -o target main.o test.o目标:依赖 \t命令列表...\n\nmake 会在当前目录下找名字叫 Makefile 或 makefile 的文件。\nmakefile 文件中有很多__目标__，如果当前目录下存在该文件，且该文件没有其他依赖，则认为该__目标__不需要更新，如果不存在该文件，就会执行 makfile 文件中目标下的命令列表来更新目标。\n\n\n1.3  Make 技巧\nmake -C 将工作目录切换到指定位置，用于上级make调用子目录中的makefile，后面加上子目录的名字即可\n\n\n2. 程序的静态编译和动态编译2.1 Linux下的动态编译2.11 动态编译__动态编译__的可执行文件需要附带动态链接库。__动态链接__可以使得进程调用其可执行文件外的函数，即动态链接库中的函数。反之__静态编译__则是把静态链接库在编译的链接阶段直接链接到可执行文件中去。\n2.12 gcc动态编译_应该叫动态链接更好？_。编译==默认==动态链接，即使用对应的动态链接库(.dll .so)生成可执行文件。\n2.13 g++动态编译同理\n2.14 如何查找可执行文件所依赖的动态链接库ldd+可执行文件名：查找可执行文件所依赖的动态链接库\n\n2.2 Linux gcc静态编译静态编译，就是编译器在编译可执行文件的时候，将可执行文件需要调用的对应静态库(.a或.lib)中的部分提取出来，链接到可执行文件中去，使可执行文件在运行的时候不依赖于动态链接库。与动态编译的区别:动态编译的可执行文件需要附带一个的动态链接库。在执行时，需要调用其对应动态链接库中的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。\n\n使用静态链接库，.lib .a。\n\ngcc -static\n\n查看动态链接版本和静态链接版本的可执行文件的字节数：\n\n\n2.3 Linux c++静态编译该Centos并不能直接静态编译c++。需要安装__libstd++-static__，利用\nwget http://mirror.centos.org/centos/8/PowerTools/x86_64/os/Packages/libstdc++-static-8.5.0-4.el8_5.x86_64.rpm \n下载安装包，rpm -ivh libstdc++-static-8.5.0-4.el8_5.x86_64.rpm --nodeps安装。\n\n2.4 打包与压缩菜鸟教程[tar](Linux tar 命令 | 菜鸟教程 (runoob.com))用法。\ntar -jcfv：-j压缩，-c，-f：后加归档名，-v：显示压缩过程\ntar -cfv：只打包不压缩，可以看大小的区别\n\n3. 动态链接库的编译和使用\ngcc -shared -fPIC -o libxxx.so xxx0.c xxx1.c\nfPIC 位置无关，可以在其他地方使用动态链接库.so文件。\n\n\n\n3.1 Linux下动态链接库__动态链接库__可以实现模块共用，多个程序可以共用一个动态链接库，而不用像静态链接那样每个使用者都要完整链接一份库。实现了代码重用。\n使用动态链接库可以更为容易地将更新应用于各个模块，而不会影响该程序的其他部分。\n3.2 动态链接库作业3.21 使用动态链接库\ngcc -shared -fPIC test1.c -o libfun.so  \n\ngcc -o test ./libfun.so test2.c  或者\n\n\n​    gcc -o test -L. libfun.so test2.c+export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH\n前者是==绝对路径==编译，若采用后者，如果没在环境变量LD_LIBRARY_PATH 上加上程序所需动态链接库的所在目录，那么运行这个程序时就会出现错误。运行时可执行文件找不到动态链接库。因此需要把当前动态链接库的目录加入系统环境变量中。\n3.22 作业2.2 (gcc)test.o:test2.c libfun.so\tgcc -o test ./libfun.so test2.clibfun.so:test1.c\tgcc -shared -fPIC -o libfun.so test1.cclean:\t@rm *.so test\n\n2.3 (c++)test.o:test2.cpp libfun.so\tc++ -o test ./libfun.so test2.cpplibfun.so:test1.c\tc++ -shared -fPIC -o libfun.so test1.cppclean:\t@rm *.so test\n\n2.4 总makefileDIRS=$(shell ls-F|grep /$)all:\t@for i in $(DIRS); do\\\t\tmake -C $$i;\\\t\tdone.PHONY=cleanclean:\t@for i in $(DIRS); do echo &quot;delete&quot; $$i; make -C $$i clean; done\n\n\n\n4. 静态链接库的编译和使用ar rcs libxxx.a xxx0.o xxx1.o xxx2.o\n4.1 Linux下静态链接库静态链接库就是你使用的.lib文件，库中的代码最后需要连接到你的可执行文件中去，所以静态连接的可执行文件一般比较大一些。\n4.2 使用静态链接库4.21 创建静态链接库文件gcc -c test1.car rcs libfun.a test1.o\n\n4.22 使用静态链接库gcc -o test test2.c libfun.a\n\n\n\n\n\n5 编译5.1 预处理gcc -E xxx.c\n将宏定义在每个位置做替换，并展开include的头文件内容。\n \ntest3. h文件中声明了两个变量、一个函数，并且将test3.c 中的宏定义N=3.13在指定位置替换。\n5.2 编译gcc -S xxx.c 生成.s文件。（编译生成的汇编代码）\n5.3 汇编gcc -c xxx.c 把汇编代码中的字符替换成二进制码，从而形成2进制的.o目标文件。\n5.4 链接随便service smb restartls -l #查看文件时间，大小\n\n问题\n 静态链接库使用默认的动态链接方式编译，删除.a文件后依然可以正常运行\n\n"},{"title":"helloworld","url":"/2022/01/28/helloworld/","content":"沁园春 · 长沙\n毛泽东\n\n\n\n独立寒秋，湘江北去，橘子洲头。\n看万山红遍，层林尽染；\n漫江碧透，百舸争流。\n鹰击长空，鱼翔浅底，\n万类霜天竞自由。\n怅寥廓，问苍茫大地，谁主沉浮？\n携来百侣曾游，\n忆往昔峥嵘岁月稠。\n恰同学少年，风华正茂；\n书生意气，挥斥方遒。\n指点江山，激扬文字，\n粪土当年万户侯。\n曾记否，到中流击水，浪遏飞舟 ！\n\n\n\n\n#include&lt;iostream&gt;using namespace std;int main()&#123;    cout&lt;&lt;123&lt;&lt;&quot;asd&quot;&lt;&lt;endl;    return 0;&#125;\n\n\n\n“从前愚民政策是不许人民受教育，现代愚民政策是只许人民受某一种教育”\n\n","categories":["helloworld"],"tags":["test"]},{"title":"https加密","url":"/2022/01/28/https%E5%8A%A0%E5%AF%86/","content":"https 加密原理http 是明文传输，所以服务端和客户端在传输数据时相当于裸奔，很容易被施行中间人攻击。\n对称加密通信双方各有一把相同的钥匙，既可以加密也可以解密，对称加密的加密速度、解密速度快，但是问题在于如何传输以及保存这个相同的密钥，显然不能直接明文传输，因此就必须依赖__非对称加密__。常用的方法是只将对称加密的密钥进行__非对称加密__然后传输，要传输的内容便可采用对称加密。\n非对称加密有以下的几种用法，假设你是客户端，A是服务器。\n1. 加密拥有两个不同的公钥、私钥，公、私钥可互相配对锁定、解锁。即公钥、私钥都可以加密，但都必须通过另一方解密。\n私钥只有一个供自己使用，公钥可以分发给想要跟你通信的其他人，要跟你通信就必须要用你给的公钥进行加密，然后你再用私钥解密即可保证信息不会泄露。（用接收方的公钥加密，接收方得到后用自己的私钥解密）\n2. 验证身份（数字签名）由于你的公钥可以被很多人拥有，但假如你只想接收A的信息，你怎么确认这个信息是A发来的而不是其他人冒充的呢或者说没有被别人篡改呢？这就要用到 数字签名 。\n数字签名的生成要用A（发送方）的私钥加密（普通加密过程是用接收方的公钥加密）。发送方A（比如服务器）先把要发送的内容经过 Hash 处理生成一个摘要，然后把摘要用A私钥加密形成签名，连同报文内容一起，用你的公钥加密然后发送给你。这时候你要用你的私钥解密A发送过来的东西，得到 数字签名+报文，由于数字签名还有一层加密，你要用A的公钥进行解密得到hash值（摘要1），然后你对得到的报文执行同样的Hash处理生成一个摘要2，如果和A发送过来的摘要1对比无误就可确认报文未被篡改。此过程要用到两套公、私钥，即一对A的，一对你自己的。\n\n验证身份：由于你用A的公钥可以解开它的数字签名就说明是A发送的。假如B想冒充A跟你通信，它虽然拥有你的公钥，但是他的数字签名没法造假，因为它没有A的私钥，不能形成A的数字签名。\n\n防止篡改：说报文被B篡改了，那么你得到的hash摘要和数字签名里的摘要一定不同，就可以判断出报文被篡改了。\n\n\n3. 数字证书上面的措施还不能保证安全，比如说B把你拥有的A的公钥偷偷换成了它自己的，那么上述的验证身份便自然而然的通过了，那么你怎么保证你拥有的A的公钥是不是真正的A的公钥呢？就要通过一个权威认证机构做公证人。认证中心用自己的私钥把A的公钥和相关信息加密，发送给你（客户端），客户端内置了认证中心的私钥，解密后得到便是真正的A的公钥，便可以进一步验证身份。\n"},{"title":"pictest","url":"/2022/01/28/pictest/","content":"\n\n\n\n\n\n\n#include&lt;iostream&gt;using namespace std;int main()&#123;    return 0;&#125;\n\n"},{"title":"二分法","url":"/2022/01/29/%E4%BA%8C%E5%88%86%E6%B3%95/","content":"二分法这里备注一下各种情况下的二分法使用\n循环条件while(left&lt;right)还是while(left&lt;=right)取决于right所取的初值是length()还是length()-1，以及右区间收缩时right=m还是right=m+1；即把右边界是开区间[left,right)还是闭区间[left,right]。\n\n一般二分法，查找数组中==target的元素位置\nwhile(left&lt;=right)&#123;//寻找==target的值    m=(left+right)/2;    if(times[m]&gt;target)        right=m-1;    else if(times[m]&lt;target)        left=m+1;    else        return m;&#125;return -1;//未查到\n条件二分法:比如此题(leetcode991)，查找第一个大于target的值，将结果-1，就是所需要的 不大于target的最大值 。都属于==搜索右区间==。\n\n备注标号提交1：采用右侧开区间搜索\n//开区间搜索//此二分法用于寻找大于target的第一个数，然后减去1是为了满足题意while(left&lt;right)&#123;//注意循环条件    m=(left+right)/2;    if(times[m]&lt;=t)&#123;        left=m+1;  //要找大于target的数，因此&lt;=的都进行左区间收缩    &#125;    else&#123;                right=m;//右区间收缩，由于右侧是开区间，right取m即是跳过了m    &#125;&#125;//return left-1;//按991题意要-1return left;/*特殊情况：\t*time[]中所有元素都 &gt;target,返回left的初值0（是一种错误）\t*time[]中所有元素都 &lt;=target，返回left==length(),数组外*/\n提交2：采用右侧闭区间搜索 ,但是提交1和提交2的左右边界收缩条件一致，因为要找大于taget的最小值，所以遇到&lt;=就左收缩，否则右收缩，区别在于右收缩的方式是m还是m-1\n//闭区间搜索while(left&lt;=right)&#123;//此二分法用于寻找大于target的第一个数，然后减去1是为了满足题意    m=(left+right)/2;    if(times[m]&lt;=t)&#123;        left=m+1;    &#125;    else&#123;        right=m-1;    &#125;&#125;//return left-1;return left;/*退出循环时right=left-1，且看前一步left==right是left右移造成的还是right左移造成的，发现无所谓，\t*如果是第一种情况，说明前一步time[left]==time[right]&lt;=target,所以要返回的一定是left右移之后的值，也就是现在的left值。\t*如果是第二种情况，说明前一步time[left]==time[right]&gt;target,right要左移动，而left此时正好是要找的值。*//*特殊情况：\t*time[]中所有元素都 &gt;target,返回left的初值0（是一种错误）\t*time[]中所有元素都 &lt;=target，返回left==length(),数组外*///与开区间一致\n注意这种寻找右边界的一定要返回left而寻找左边界要返回right。由于while(left&lt;right)的方式，当[a,a)搜索区间已经为空，此时left==right也刚好退出循环，所以返回left和right并无致。而当while(left&lt;=right)方式时，搜索区间[a,a]时并不为空，所以只有当right&lt;left时才为空，\n\n\nwhile(left&lt;=right)&#123;//此二分法用于寻找大于target的第一个数，    m=(left+right)/2;    if(times[m]&gt;t)&#123;        right=m-1;    &#125;    else&#123;        left=m+1;    &#125;&#125;return left-1;\n条件二分法：==搜索左区间==，寻找最后一个小于target的值的下标\n\n开区间搜索\n//开区间搜索//此二分法用于寻找小于target的最后一个数while(left&lt;right)&#123;//注意循环条件    m=(left+right)/2;    if(times[m]&gt;=t)&#123;        right=m;  //要找小于target的数，因此&gt;=的都进行右区间收缩    &#125;    else&#123;                left=m+1;//左区间收缩    &#125;&#125;return right;//注意返回值是right/*特殊情况：\t*time[]中所有元素都 &lt;target,返回right的初值,即time.length(),数组外\t*time[]中所有元素都 &gt;=target，返回right==0*/\n闭区间所搜\n//闭区间搜索//此二分法用于寻找小于target的最后一个数while(left&lt;=right)&#123;//注意循环条件    m=(left+right)/2;    if(times[m]&gt;=t)&#123;        right=m-1;  //要找小于target的数，因此&gt;=的都进行右区间收缩    &#125;    else&#123;                left=m+1;//左区间收缩    &#125;&#125;return right;//注意返回值是right/*特殊情况：\t*time[]中所有元素都 &lt;target,返回right的初值,即末尾元素对应的下标(即time.length()-1)\t*time[]中所有元素都 &gt;=target，返回right==-1\t与开区间错了一位。*/\n\n\n\n总结\n右区间搜索&lt;=同属左边界收缩，&gt;属于右边界收缩。返回left（包含等号的条件是左边界收缩，因此返回左边界）\n什么符号单独（不与等号同收缩），就找满足什么符号条件的值，比如&gt;单独，就找&gt;target的最小值。\n\n\n左区间搜索&gt;=同属右边界收缩，&lt;属于左边界收缩。返回right，由于循环条件的不同，right初值不同，因此返回时要注意讨论特殊情况，见上面代码块。\n右区间搜索则不需要考虑，因为left初值永远是0。\n\n\n注意，leetcode991只能查找目标值之前或者等于目标时间的值，即&lt;=，所以是右区间搜索结果-1。而不能用左区间搜索+1。当然也可以用左区间搜索，只要把条件修改为寻找&lt;=target的最大值即可，此时&lt;=左边界收缩\n\n==结论==:左区间所搜，left的条件就是要找的条件（究竟是&lt;还是&lt;=取决于left的条件）。\nint left=0,right=times.size()-1,m;        while(left&lt;=right)&#123;            m=(left+right)/2;            if(times[m]&gt;t)&#123;  //注意没有等号，等号在下面的条件中                right=m-1;            &#125;            else&#123;                left=m+1;//            &#125;        &#125;        return right;//可以发现竟然与右区间搜索一致，这里即使991题的答案，不用再减1了\n\n","categories":["算法"],"tags":["leetcode"]},{"title":"守护进程","url":"/2022/01/28/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/","content":"守护进程1. 正常程序的后台运行及前后台切换1.1 示例程序Linux下间隔5s输出一句话的死循环程序。\n#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123;\tprintf(&quot;%d&quot;,1752846);\tsleep(5);&#125;return 0;\n\n1.2 后台运行1.2.1 开始时设定为后台运行命令+&amp; 程序运行时直接在后台进行，但是依然会在前台显示，此时shell命令行功能依然可用，但是显示会受影响。若不加&amp;，即默认在前台执行，此时无法使用shell命令工具。\n1.2.2 作业和进程shell ：命令解释器，其实就是一个脚本语言解释器，有很多种(bash,ash,tcsh等),最常用的是bash.job(作业): 是相对shell 来说的，在shell中执行一条命令，实际上就是提交了一个job,只不过有的job需要运行很长时间，有的job很快就结束。进程：命令经过shell解析后，交给系统内核执行，会fork出很多进程，他们同属于登录shell的进程组，如下图。！！！所以作业是shell里面的一个概念，jobs命令只能查看当前shell自己的job，不同的shell 之间相互隔离。我们在shell里执行一条命令的时候就开启了一个作业，一个作业对应着系统中的一个进程组，如果作业中的某个进程又创建了子进程，则子进程不属于作业。\n\n1.2.3 在启动后切换到后台运行ctrl+z将进程挂起，bg + % + 作业号将挂起的进程放到后台继续执行。\nctrl+c 将前台进程终止。\njobs 查看后台执行的进程。\nfg + % + 作业号 将后台进程放到前台执行。\nkill + % + 作业号 杀死后台进程。\n\n放在前台执行的程序可以直接ctrl+c结束掉，而后台运行的程序需要通过kill + % + n杀死。当前台运行程序时，命令行功能无法使用。\n\n\n父进程查看\nps -p +进程号 + -l：PPID就是父进程号。\n当前子进程的父进程号就是终端的进程号。\n\n\n再登陆另一个控制台，如何查看这两个进程的信息。\n此时通过jobs无法查看，因为作业shell隔离。\njobs是查看当前后台作业（进程），是获取本次bash下的后台作业。​​​​当本次终端退出后，后台作业变成孤儿进程，孤儿进程有系统父进程接管。当再次连接终端时，原作业与当前终端，不存在关系父子关系，故看不到进程。但是原作业，会在系统中一致运行，直到完成或被停止。这就是为什么终端退出后，jobs看不到的原因了\n\n\n\nps -a\n\n\nctrl+D退出控制台后，在另一个控制台查看。\njobs无显示，说明查看不了，ps a也看不到进程了，说明进程没了。logout 也是如此。\n此时利用子进程号查看父进程PPID=1?\n\n下图是关闭shell前 / 后\n\n\n\n如果通过exit则依然可以查看到进程，只是进程状态是T:暂停状态。ctrl+z挂起前台进程也会显示状态T。\n\n退出终端后，打印信息是否能出现在新登录的终端上？\n==不可以==，一般的进程都是。？\nshell关闭时会向进程组所有进程发送sighup信号。\n当用户注销或者网络中断时，终端后收到SIGHUP信号，从而关闭其所有子进程，以上两种方式会随着终端的关闭而退出，如果我们需要作业在后台执行并不受终端退出的影响，可以用nohup+命令+&amp;方式。nohup命令会忽略__SIGHUP__信号，从而终端退出时不会影响到后台作业。\n\nnohup: no hang up。\n\n\n\n1.24问题\nnohup无效，即关闭shell进程就被杀死了\nshell、terminal、bash、console区别\nctrl+D exit logout 区别\n父进程号PPID=1就是僵尸进程?\n\n2. 守护进程的作用、用途、父进程标识的特点 创建子进程，父进程退出　　这是编写守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在Shell终端里造成一程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离。　　在Linux中父进程先于子进程退出会造成子进程成为孤儿进程，而每当系统发现一个孤儿进程是，就会自动由1号进程（init）收养它，这样，原先的子进程就会变成init进程的子进程。​ 在子进程中创建新会话　　这个步骤是创建守护进程中最重要的一步，虽然它的实现非常简单，但它的意义却非常重大。在这里使用的是系统函数setsid，在具体介绍setsid之前，首先要了解两个概念：进程组和会话期　　进程组：是一个或多个进程的集合。进程组有进程组ID来唯一标识。除了进程号（PID）之外，进程组ID也是一个进程的必备属性。每个进程组都有一个组长进程，其组长进程的进程号等于进程组ID。且该进程组ID不会因组长进程的退出而受到影响。　　​ 会话周期：会话期是一个或多个进程组的集合。通常，一个会话开始与用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话期。　　接下来就可以具体介绍setsid的相关内容：　　（1）setsid函数作用：　　setsid函数用于创建一个新的会话，并担任该会话组的组长。调用setsid有下面的3个作用：　　让进程摆脱原会话的控制　　让进程摆脱原进程组的控制　　让进程摆脱原控制终端的控制　　那么，在创建守护进程时为什么要调用setsid函数呢？由于创建守护进程的第一步调用了fork函数来创建子进程，再将父进程退出。由于在调用了fork函数时，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，还还不是真正意义上的独立开来，而setsid函数能够使进程完全独立出来，从而摆脱其他进程的控制。​ 改变当前目录为根目录　　这一步也是必要的步骤。使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统（如“/mnt/usb”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入单用户模式）。因此，通常的做法是让&quot;/&quot;作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp。改变工作目录的常见函数式chdir。​重设文件权限掩码　　文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限。由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为0，可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是umask。在这里，通常的使用方法为umask(0)。​ 关闭文件描述符　　同文件权限码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。\n\n\n\n2.1 ★★★直接成为守护进程(步骤)★★★2.11 脱离终端控制，成为后台进程\nfork()创建子进程，父进程 exit()退出\n\n这是创建守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在Shell终端里造成程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在 Shell 终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作。\n\n\n\n为什么要 fork ：fork()子进程后，使用exit()退出父进程，Shell 便认为父进程终止了，不再挂在终端上，因此可以使得子进程脱离终端控制，同时由于子进程一定在父进程所在的进程组中，因此它一定不是进程组长，所以才能保证下一步setid()的成功调用。\n\n2.12 创建新的会话(session)\n只有该进程不是进程组长时，才会创建新的会话期。\n在调用了 fork() 函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来。\n\n\n摆脱原会话的控制。该进程变成新会话期的首进程\n摆脱原进程组。成为一个新进程组的组长\n摆脱终端控制。如果在调用 setsid() 前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误。\n\n2.13 再次fork孙进程，让子进程退出\n因为会话组的组长有权限重新打开控制终端，所以这里第二次调用fork()将子进程结束，留着孙进程，孙进程不是会话组的组长所以没有权利再打开控制终端，这样整个程序就与控制终端隔离了。\n\n2.14 更改子进程的工作目录源自网站 【Linux编程】守护进程(daemon)详解与创建_mick_seu的博客-CSDN博客_daemon()](https://blog.csdn.net/woxiaohahaa/article/details/53487602))\n\n在子进程中调用 chdir() 函数，让根目录 / 成为子进程的工作目录.。\n这一步也是必要的步骤。使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统（如“/mnt/usb”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入单用户模式）。因此，通常的做法是让&quot;/&quot;作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp。改变工作目录的常见函数是chdir。\n\n2.15 重设文件权限掩码文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限。由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为0，可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是umask。在这里，通常的使用方法为umask(0)。\n\n2.16 在子进程中关闭不需要的文件描述符同文件权限码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，文件描述符为0、1和2 的3个文件（常说的输入、输出和报错）已经失去了存在的价值，也应被关闭。\n\n2.17 代码//test2.c#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/param.h&gt;#include &lt;sys/stat.h&gt;#include &lt;time.h&gt;#include&lt;stdlib.h&gt;int my_daemon()&#123;\tpid_t pid;\tint i;//创建子进程\tpid=fork();\tif(pid&gt;0)&#123;    //如果成功，退出父进程\t\tprintf(&quot;子进程号：%d&quot;,pid);\t\texit(0);\t&#125;\telse if(pid&lt;0)   //如果失败\t\treturn -1;\tsetsid();    //子进程脱离原会话，成为新的session leader\tpid=fork();  //创建孙进程\tif(pid&gt;0)&#123;\t\tprintf(&quot;孙进程号：%d&quot;,pid);\t\texit(0);\t&#125;\telse if(pid&lt;0)\t\treturn -1;\t\tumask(0); //文件权限掩码\tchdir(&quot;/&quot;); //设置工作目录为根目录\tsignal(SIGCHLD,SIG_IGN);\treturn 0;&#125;void func()&#123;\twhile(1)&#123;\t\tprintf(&quot;%d\\n&quot;,1752846);\t\tsleep(5);\t&#125;&#125;int main()&#123;\tmy_daemon();\tfunc();\treturn 0;&#125;\n\n2.2 守护进程的进程标识、父进程程序作为守护进程运行，命令行功能不受阻碍，jobs显示无，说明进程已经脱离了该终端的控制。\n\n\nps l -C+可执行文件名 可以查看守护进程信息，其父进程为1。\n?表示不属于任何终端。\nps -A可以查看所有进程\n2.3 在其他控制台看守护进程可以查看。\n2.4 如果ctrl+D退出会怎样？守护进程不受影响，依然在运行。\n2.5 再次登录控制台重新登里后，守护进程依然在运行，但是打印信息并不会出现在终端上了。\n3. 守护进程再次分裂子进程（僵尸进程的处理）fork()函数调用一次，返回两次，因为产生了一个子进程。\n\n当前是父进程，则返回创建的子进程的 ID 。\n当前是子进程，返回 0 。\n出现错误，返回 __负数__。\n\n3.1 作业，分裂进程#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/param.h&gt;#include &lt;sys/stat.h&gt;#include &lt;time.h&gt;#include&lt;stdlib.h&gt;//子进程void child_process()&#123;    pid_t pid,ppid;    for(int i=0;i&lt;3;i++)&#123;        pid=getpid();        ppid=getppid();        printf(&quot;%d-%d-1752846-sub\\n&quot;,pid,ppid);        sleep(25);    &#125;&#125;int main()&#123;    int Max=10;    pid_t pid,ppid;    while(Max)&#123;        Max--;        pid=fork();        if(pid==0)&#123;            child_process();            exit(0);   //子进程循环3次后结束        &#125;        sleep(3);    &#125;    while(1)&#123;        pid=getpid();        ppid=getppid();        printf(&quot;%d-%d-1752846-main\\n&quot;,pid,ppid);        sleep(5);    &#125;    return 0;&#125;\n\n3.2 循环 fork( )3.21 示例1（作业）static int a=0;int main()&#123;\tfor(int i=0;i&lt;3;i++)&#123;\t\tfork();\t\tprintf(&quot;%d&quot;,a);         a++;\t&#125;\treturn 0;&#125;\n\n输出结果是012循环8次。说明fork()得到的子进程继承从父进程fork()之后的语句。\n因此第一次循环，父进程 0 放入缓冲区一个0，产生一个子进程 1，子进程 1 也放入缓冲区一个0。\n第二次循环，父进程 0放入1，产生子进程 2，子进程1也放入1，子进程 2 放入0。子进程1又产生子进程3，也放入0 ；此时有0123四个进程，缓冲区内分别是01 01 0 0  \n第三次循环，上面四个进程都飞别再产生一次子进程，然后父进程0结束，子进程跟着结束，\n最后输入012 ...*8（循环8次）。\nprintf(&quot;x\\n&quot;);\n\n！！注意，如上所示，如果输出语句中带换行符，也就是立即刷新输出，此时二重循环输出 6 次，而不带\\n则输出 8 次。我猜测原因在于子进程继承了父进程缓冲区中的内容。\n由于子进程只继承从fork()之后的句子，因此只继承了后半循环部分的循环语句，比如说i=2之后的循环，最后一次循环的子进程则直接跳出循环。\n\n那么如果不立即刷新缓冲区，会使得缓冲区中的内容被继承，因此这种输出的结果就相当于最后所有进程都输出一次完整序列，如demo中的012。第一次循环后，一共有2个进程，第三次循环后，一共有2^3=8个进程，因此一个产生了 8 个012。\n如果刷新了缓冲区，即带有\\n，缓冲区内的东西不会被继承。\n\n3.22 示例2int main()&#123;\tfor(int i=0;i&lt;2;i++)&#123;\t\tfork();\t\tprintf(&quot;X&quot;);\t&#125;\treturn 0;&#125;//  输出 8 次 X \n\n​    用前面的解释便能说通，此时序列是XX，循环后共 4 个进程，因此产生了 8 个X。\n3.23 示例3int main()&#123;\tfor(int i=0;i&lt;2;i++)&#123;\t\tfork();\t\tprintf(&quot;X\\n&quot;);\t&#125;\treturn 0;&#125;// 输出 6 次 X\n\n 缓冲区没东西可被继承，因此第一次循环产生的结果是有两个进程，输出2个X，第二次循环产生4个进程，在输出4个X，所有进程都结束了，因为此时再产生的子进程，已经无法进入循环了，循环次数=2了。\n3.3 僵尸进程__僵尸进程__：一个进程使用fork()创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的结束状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。即父进程需要查看一下子进程，验尸。。\n\n其状态栏显示Z。\n\n\n危害：如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。\n用处：由于子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程 到底什么时候结束，因此子进程释放后会保留相关的信息。\n\n3.4 如何杀死僵尸进程对于一个定期的产生子进程的父进程，产生的子进程需要做的事情很少，子进程做完该做的事情之后就退出了，故生命周期很短。但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉，即通过通过kill发送SIGTERM或者SIGKILL杀死父进程。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了\n\n3.5 如何实现子进程退出后不存在僵尸进程signal(SIGCHLD,SIG_IGN);// 忽略子进程结束的信号，直接交给init进程管理，\n\n\n\n4. 如何杀死守护进程？如何杀死守护进程的子进程4.1 杀死某个进程kill+ 进程号\n4.2 快速杀死某个父进程所有子进程pkill -P + 父进程号\n4.3 杀死某个进程后，其子进程如何？PPID 全部变成了 1 。\n\n4.4 如何做到杀死某个进程后，自动结束其所有子进程？5. 守护进程的再次分裂子进程（极限测试）5.1 分裂数达到多少会分裂失败5.2 虚拟机内存为1024MB、2048MB时呢？\n\n5.3 将子进程中字符数组扩大10倍与单个进程所占用内存无关？因为即使将数组设置为大小1也是如此。\n5.4"}]