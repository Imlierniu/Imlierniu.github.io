[{"title":"C++笔记1","url":"/2022/01/28/C++%E7%AC%94%E8%AE%B01/","content":"类\n\n成员函数属于类而数据成员属于对象\ntypedef struct Student&#123;int x;char *name;&#125;N;//用N代替Studenttypedef int *N;N p;//p为int*类型typedef int array[10];array a;//相当于int a[10];//把变量名替换成新类名\n构造函数（默认与重载）\nClassA();//无参构造函数，默认构造函数ClassA(int a,int b,int c=10);//重载ClassA(10,10,10);//全部为默认参数，属于默认构造函数，//在声明时指定默认值，而不需要在定义时再指出来ClassA x;      //只能有一个默认构造函数，而且最好不要把有默认参数的构造函数和重载放在一起使用\n\n\nconst\n\n常指针，指向地址不变  int *const p; \n指针常量，不能修改指向的值  const int *p ,int const *p;\nconst默认作用于其左边，否则右边。  \n\n\n\n\n类模板\n&gt;template&lt;class T&gt;class Student&#123;&#125;; //模板类定义Student&lt;int&gt;a; //用模板类定义对象实体template&lt;class T&gt;void Student&lt;int&gt;::print()&#123;...&#125;;//在模板类外定义成员函数，每一条头部都要加template\t\n\n\n\n构造函数\n1.默认构造函数\n无参数\n所有参数均给出默认值\n\n\n二者有一定区别，第二种可以指定参数传入，会将默认值替换掉。\n只有定义了默认构造函数才能初始化对象。\n\nStudent(int a=5, int b=5)//func1\t&#123;\t\tx = a;\t\ty = b;\t&#125;Student()//func2&#123;    x=5;    y=5;&#125;//二者都是默认构造函数，不能同时出现，二者有区别。//以下两种方式都可以调用默认构造函数,无论是func1还是func2Student st；Student st1=Student();\n\n&gt;//派生类构造函数调用直接基类构造函数是可以选择&gt;Circle::Circle(int a,int b,int c):Point(a,b)&gt;&#123;\t\t\t\t\t\t\t\t\t\t\t\t//参数化列表可用于调用基类构造，初始化r也可，初始化类子对象r = c;&gt;&#125;\n\n\n\n2.赋值构造函数&gt;Student st2;&gt;st2=st;  //相当于赋值给一个已经被构造函数初始化过的对象，而复制构造函数是将未初始化的进行初始化。\n\n\n\n3.复制构造函数\n用已存在对象初始化一个新对象时\n\nStudent st2=st1;\n\n\n函数参数为对象时\n\nvoid func1(Student &amp;st)&#123;&#125;   //将实参复制一个形参传入\n\n\n返回值为对象时\n\nStudent func2()&#123;return st;&#125;  //返回时复制一个临时对象返回，其他函数内部的东西在函数结束时释放了，因此不能返回局部变量的引用值\n\n\nextern变量extern int a; // 声明一个全局变量 aint a; // 定义一个全局变量 aextern int a =0 ; // 定义一个全局变量 a 并给初值。int a =0;    // 定义一个全局变量 a, 并给初值\n\n在定义变量的时候，这个extern居然可以被省略(定义时，默认均省略)；在声明变量的时候，这个extern必须添加在变量前，所以有时会让你搞不清楚到底是声明还是定义。或者说，变量前有extern不一定就是声明，而变量前无extern就只能是定义。注：定义要为变量分配内存空间；而声明不需要为变量分配内存空间。\n声明不分配空间。而定义即使不赋值也会分配空间。声明可以多次，所以不能在头文件中定义，否则不能被多个文件include。\n==在哪里使用变量就在哪里写extern==，告诉编译器这个变量在其他地方定义了。\n\n在A文件中使用B文件中变量x的两种方法\n\n同一工程下，在A中extern int x，在B中定义x。\n在B.h中extern int x；B.cpp中定义；在A中#include”B.h”。相当于头文件帮你声明过了，你不用自己一个一个extern。\n\n函数由于声明和定义不一样，所以可以不必考虑extern。\n\n函数==由于函数的定义和声明具有可见性的区别，所以可以省略extern。==对于函数也一样，也是定义和声明，定义的时候用extern，说明这个函数是可以被外部引用的，声明的时候用extern说明这是一个声明。 但由于函数的定义和声明是有区别的，定义函数要有函数体，声明函数没有函数体(还有以分号结尾)，所以函数定义和声明时都可以将extern省略掉，反正其他文件也是知道这个函数是在其他地方定义的，所以不加extern也行。两者如此不同，所以省略了extern也不会有问题。\n\n\n手动extern 声明（extern可省略）\n在头文件中声明，引入头文件。==不可在头文件中定义函数==，使得头文件不可被多次引用。\n\n\nstatic和extern函数\nauto和extern变量\n123\n函数指针数组，\ninline函数定义必须放在.h文件中\n函数对象和函数指针\n输入控制\n&gt;#include&lt;iostream&gt;&gt;using namespace std;&gt;int a;&gt;while(1)&gt;&#123;cin&gt;&gt;a;//if(!cin)if(!cin.fail())&#123;\tcin.clear();\tcin.ignore(1024,&#x27;\\n&#x27;);\t//cin.sync();\tcontinue;&#125;&gt;&#125;\n\n数组作为参数\n==在C/C++中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针==\n\n\nCSDN，这里第一个例子中当data数组经过一个函数传进去之后，在里面就变成指针类型了。\n\n\n一维数组\n\n&gt;const int n=10;&gt;int a[][n];&gt;//一维数组传参&gt;show(int *p);&gt;show(int a[]);&gt;//动态数组&gt;int *p;&gt;p=new int[10];\n\n\n\n\n二维数组，必须指定列数，否则系统无法分配行和列\n\n ==二维数组做参数==\n&gt;//二维数组作为参数的两种写法&gt;void show(int a[][n]);  //n必须与实参相同！！&gt;void show(int (*p)[n]);//int (*p)[n]为指向n长度的地址块的指针&gt;// 而int *p[n]为长度为n的指针数组&gt;//动态二维数组两种&gt;int(*p)[10];//1.已知列数时,动态分配多少行这样的&gt;p=new int[x][10？];&gt;//2.未知列数时，先开辟一个指针数组，每个指针开辟一行&gt;int **q=new int*  [row]; //申请row个指向一维数组的指针(row长度的指针数组，指针数组作为行数)&gt;for(int i=0;i&lt;row;i++)&gt;&#123; q[i]=new int[col]; //row个数组，每个数组长度为col(col长度的块，块作为列)&gt;&#125;\n\n\nnew 函数返回值是开辟内存的地址，如果要开辟一个指针数组，那么只能将值返回给一个二级指针，因为返回值是指向指针的指针。固不能用int * q=new int *[10];\nmalloc 函数也是如此。\n\n\n&gt;for(int i=0;i&lt;row;i++)&gt;&#123; delete []p[i]; //删除所有的行数组空间，p[i]为指针变量，前面的[]代表指向的是一个数组空间，删除每一行&gt;&#125;&gt;delete []p; //删除p指向的列空间&gt;p=NULL;\n\n&gt;//malloc&gt;int **p=NULL,i=0;&gt;p=(int **)malloc(sizeof(int *)*SIZE);&gt;for(;i&lt;SIZE;i++)&gt;&#123; *(p+i)=(int *)malloc(sizeof(int )*4);&gt;&#125;\n\n\n ==二维数组作为返回值该怎么写?==，int **和int[][10]的区别；见下程序已知列数的malloc返回值。\n 返回指针数组时用 **\n\n&gt;#include&lt;stdio.h&gt;&gt;#include&lt;windows.h&gt;&gt;#include&lt;iostream&gt;&gt;using namespace std;&gt;int main()&gt;&#123;   //动态二维数组   //new版本   int **p = NULL;   p = new int *[3];   for (int i = 0; i &lt; 3;i++)&#123;       p[i] = new int[3];       for (int j = 0; j &lt; 3;j++)&#123;           p[i][j] = i * 3 + (j + 1);       &#125;   &#125;   for (int i = 0; i &lt; 3;i++)&#123;       for (int j = 0; j &lt; 3;j++)&#123;           cout &lt;&lt; p[i][j] &lt;&lt; &quot; &quot;;       &#125;       cout &lt;&lt; endl;   &#125;   cout &lt;&lt; endl;   //malloc版本   int **q = 0;   q = (int **)malloc(sizeof(int *) * 3);   for (int i = 0; i&lt; 3;i++)&#123;       q[i] = (int *)malloc(sizeof(int) * 3);       for (int j = 0; j &lt; 3;j++)&#123;           q[i][j] = i * 3 + j + 1;       &#125;   &#125;   for (int i = 0; i &lt; 3;i++)&#123;       for (int j = 0; j &lt; 3;j++)&#123;           cout &lt;&lt; q[i][j] &lt;&lt; &quot; &quot;;       &#125;       cout &lt;&lt; endl;   &#125;   cout &lt;&lt; endl;   /***********************************************************************/   //动态二维数组（已知列长）   //new   int(*r)[3];//相当于指定了每一行行长度（即列数），再开辟n行   r = new int[2][3];   for (int i = 0; i &lt; 2;i++)&#123;       for (int j = 0; j &lt; 3;j++)&#123;           r[i][j] = i * 3 + j + 1;           cout &lt;&lt; r[i][j] &lt;&lt; &quot; &quot;;       &#125;       cout &lt;&lt; endl;   &#125;   cout &lt;&lt; endl;   //malloc   int(*s)[2];   s = (int (*)[2])malloc(sizeof(int)*3*2); //注意这是指定了2列，s类型应当为int(*)[2],即2列的行指针类型，因此若写函数返回值时，就这样写。int *[2]   for (int i = 0; i &lt; 3;i++)&#123;       for (int j = 0; j &lt; 2;j++)&#123;           s[i][j] = i * 3 + j + 1;           cout &lt;&lt; s[i][j] &lt;&lt; &quot; &quot;;       &#125;       cout &lt;&lt; endl;   &#125;&gt;&#125;\n\n\n\n\n\n while\n 形参不是const指针，不能传入const指针。而形参是const指针，既可以传入const也可以传入非const；\n\n\n指针*和引用&amp;做参数的区别\n指针任然是单向传值，把指针内容赋给一个临时指针变量。而引用是形参实参双向传递的，传递的就是实参本身。\n&gt;void show(int *p,int&amp; a)&gt;&#123;...&#125;&gt;int main()&gt;&#123;int x=1;int y=2;show(&amp;x;y);  //注意，这里x是传指针(地址)，地址存放在新的临时变量p中；而y才是传引用。&gt;&#125;\n\n数组与指针表示&gt;int a[10];&gt;//地址 &amp;a[i]=a+i&gt;//取值 a[i]=*(a+i)&gt;// &amp;a是数组首地址，整块遇到的问题\n\n指针做参数遇到的问题\n在main函数中创建一个自定义类型 student *st 指针，将指针传入一个用于初始化的函数中，void show(student *) ，在里面使用new。然后利用 Print 函数输出时，会提示 st 未使用。\n&gt;struct student&gt;&#123;int a;int b;&gt;&#125;;&gt;void show(student *st)&gt;&#123;st=new student[10];&gt;//...&gt;&#125;&gt;void Print(student *st)&gt;&#123;&gt;//...&gt;&#125;&gt;int main(&gt;&#123;student *st=0;&gt;show(st);&gt;Print(st);&gt;&#125;\n\n由于指针作为函数参数本质上仍然是传值，相当于在 show 函数内部一个新临时指针 st （而不是主函数的 st ）来执行 new，而 main 函数中的 st 指针仍然是0。解决办法就是将 show 函数返回值设置为 student* 类型，返回局部 st，在 main 函数中让st=st；或者是传递一个指针的引用。\n&gt;int main()&gt;&#123;student *st=0;st=student *show(st);Print(st);&gt;&#125;\n\n原因类似于下面这种\n&gt;int main()&gt;&#123;&gt;int *p = NULL;&gt;int *s = p;&gt;s = new int[10];&gt;s[0] = 1;&gt;//p = s;   //!!不加此语句，无法输出p[0]&gt;cout &lt;&lt; p[0];&gt;&#125;&gt;//以及这种&gt;int main()&gt;&#123;&gt;int *p = NULL;&gt;int *s = p;&gt;p = new int[10];&gt;p[0] = 1;&gt;cout &lt;&lt; s[0];//也会提示s是nullptr&gt;&#125;\n\n在不同函数中进行链表操作时也会遇到这样的问题，加一个头节点也可以解决这种问题。因为有了头节点，即使是传值也无所谓，即函数和主函数中的head都可以用来操作头节点中的变量，让head-&gt;next，指向下一个节点即可。\n\n如果函数内要改变的是指针指向的内容，传递指针值即可\n如果函数改变的是指针本身，需要传递指针的引用\n\n&gt;void ReadFile(student*head)&gt;&#123;student *q = head,*p=NULL;&gt;&#125;&gt;int main()&gt;&#123;   student *head;head = new student;head-&gt;next = NULL;ReadFile(head);&gt;&#125;\n\n\n\n二维数组与指针\n&gt;int main()&gt;&#123;int a[3][3] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;int *p = a[1];//int *q = a + 1;cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; a + 1 &lt;&lt; &quot; &quot; &lt;&lt; &amp;a[1] &lt;&lt; endl; //行地址cout &lt;&lt; a[0] &lt;&lt;&quot; &quot; &lt;&lt; *(a+1) &lt;&lt;&quot; &quot;&lt;&lt;a[1];//元素地址（某行第一个元素的地址）&gt;&#125;\n\n\n从上述代码的输出结果来看，好像两行是完全一致，事实上二组值意义完全不同。\n第一组表示的是行向量的  ==行地址==，而第二组代表的是对于行的==0列地址==。\n\n二维数组A[3][4]可以看作是三个元素a组成，每个元素a都是一个长度为 4 的数组。所以a和&amp;a[0] 代表的是第一个a元素的地址，*a 和 a[0] 则表示第一个a元素（长度为4的数组）的第一个元素的地址。\n\n&gt;int main()&gt;&#123;int a[3][3] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;int *p = a[1][1];//int *q = a + 1;cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; a + 1 &lt;&lt; &quot; &quot; &lt;&lt; &amp;a[1] &lt;&lt; endl;cout &lt;&lt; a[0] &lt;&lt;&quot; &quot; &lt;&lt; *(a)+1 &lt;&lt;&quot; &quot;&lt;&lt;a[0]+1;   //对行地址解除引用得到元素a的值，即每个列数组的首元素地址&gt;&#125;\n\n\n\n\n\n\n\n二维数组在内存中连续存放，下图乍一看很秀的样子，其实都是利用了这一特性，p为列地址（第一行第一个元素），自增后指向第一行第二个，第一行结束后自增会指向第二行第一个元素，因为连续存放。\n\n\n这题很牛啊\n\n字符串其实就是一个个首地址，首先把四个字符串的首地址存放在一个指针数组里，即现在有4个指向这些字符串的指针，只要对这4个指针解引用* 即可得到四个字符串的地址，cout+首地址会输出整个字符串直到遇到&#39;\\0&#39;。\n新建一个指针数组 p，里面4个指针元素指向c+i（p[0]=*p+0=c+3） ，c+i 的意思是数组 c 四个元素（即前面的4个指针）的地址（因为*(c+i)==c[i]）。然后让指针 pp 指向 p 的首位，即 pp 中存放的是数组 p 第一个元素的位置。\n开始操作:  首先++ 优先级大于 * , pp 指向数组 p 中第二个元素。第一次解除引用，得到 c+2 ,(即数组 c 中元素的地址);第二次解除引用，即*(c+2)=c[2] ，得到第3个字符串__首地址__。输出即是==You==。\npp 和 p 是一样的，就像int *p,a[10];p=a;只是 pp 可以指向别处，而 p 只能指向数组第一个元素。pp[-2]=*(pp-2)，即 c+3 ，*(c+3) 得到最后一个字符串首地址，+3 是字符串第4个字符串地址，即空格，所以输出==空格+very== 。 \n\nNULL\n以下是C++一教材的解释:指针应在声明时或在赋值语句中初始化。指针可以初始化为0、NULL或—个地址。数值为0或NULL的指针不指任何内容。NULL是头文件&lt;iostream.h&gt;(和另外几个标准库头文件)中定义的符号化常量。将指针初始化为NULL等于将指针初始化为0，但C++中优先选择0。指定0时，它变为指针的相应类型。数值0是惟一可以不将整数转换为指针类型而直接赋给指针变量的整数值。\n指针指向 NULL 和空串&quot;&quot; 的区别，&quot;&quot; 里有一个 &#39;\\0&#39; ,虽然 NULL==&#39;\\0&#39;  ,但是一个是包含，一个是指向。\n&gt;char a[] = &quot;&quot;;if(a[0]==&#x27;\\0&#x27;)\tcout &lt;&lt; 1;if(&#x27;\\0&#x27;==NULL)\tcout &lt;&lt; 2;if(NULL==0)          \tcout &lt;&lt; 3;//输出123//int*b=NULL;b==NULL;b!=&#x27;\\0&#x27;,c++标准规定不允许指针和值进行比较\n\n\n文件读取\n因为文件指针到最后一个字符时并不会触发eof,再读一次读不到数据才触发eof,这样c还保留着上一次的数据，又被输出一次，peek()方法是读取文件指针下一个位置的值，但并不移动文件指针，用在这里很合适\n&gt;ifstream infile(&quot;&quot;,ios::in);&gt;while(!infile.eof())//我们利用while循环将文件读入char数组中&gt;while(infile.peek()!=EOF)&gt;//这两个的区别&gt;/*若不用peek，char数组会读入一个EOF，file.eof()并不会读文件，因此它必须在读取之后判断，   所以当读到最后一个字符时，eof()不会读下一个，而是读当前的，因此当读到EOF之后，eof()才为真，   此时才退出循环&gt;*/&gt;//由于peek()和eof()一样只判断而不读取，而peek()是指向后一个，当读到最后一个字符，然后判断下一个是不是EOF，是就退出循环，就很科学了，\n\n所以正确的写法应当是先读&gt;&gt; 再判断；因为只有读了才能判断\n\n\n[TOC]\n\n​    \n","categories":["c++"]},{"title":"helloworld","url":"/2022/01/28/helloworld/","content":"shenmdjkslajdlkasjdjlasldajsdjalskdjklasjdjaslkjdlkajdkjaslkdja;jdilhwihdnkjahdjkhiawhdjahuidhaskjdhakshduiahsjdkhasudhsakjd\n#include&lt;iostream&gt;using namespace std;int main()&#123;    cout&lt;&lt;123&lt;&lt;&quot;asd&quot;&lt;&lt;endl;    return 0;&#125;\n\n","categories":["abc"],"tags":["test"]},{"title":"pictest","url":"/2022/01/28/pictest/","content":"\n"}]